# **RabbitMQ入门学习记录**

> 项目需要用到RabbitMQ传输些数据，因此准备快速上手使用一下，这边只记录简单的入门步骤，后续有时间还得深入研究研究。

## **安装**

1.rabbitmq安装：<https://www.rabbitmq.com/download.html> + 环境变量配置

2.Erlang安装：<http://www.erlang.org/downloads> + 环境变量配置

## **启动**

1.安装路径/sbin/rabbitmq-server.bat （双击启动）

![1557902352305](E:\git\知识点整理\figure\RabbitMQ启动.png)



2.可视化管理界面：http://localhost:15672

## **知识点**

1.消息队列基本概念(Queue，Exchange，Channel，connection等)，优势，使用场景等。

2.权限管理（包括用户，虚拟主机等的添加与管理）可视化界面的使用与基本操作。

3.消息传递的模式（单播，广播，Topic，Header等)及基本的生产者消费者队列配置方法。

4.消息确认机制实现（ACK，Confirm等）。

### 基本介绍：

​    RabbitMQ即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。

​    RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。

​    AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。

​    RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。

#### **AMQP：**

AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准**高级消息队列协议**,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。

#### **消息队列**

MQ全称为Message Queue，消息队列。是一种应用程序对应用程序的通信方式。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。

**消息传递**指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。队列的使用除去了接收和发送应用程序同时执行的要求。

**在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。**

#### **为什么使用RabbitMQ？**

它支持Work Queue等不同的消息处理方式，可以用于不同的业务场景。使用消息队列，可以将不算紧急、但是非常消耗资源的计算任务，以消息的方式插入到RabbitMQ的队列中，然后使用多个处理模块处理这些消息。

这样做最大的好处是：**提高了系统的峰值处理能力。**因此，来不及处理的消息缓存在RabbitMQ中，避免了同时进行大量计算导致系统因超负荷运行而崩溃。而那些来不及处理的消息，会在峰值过去之后慢慢处理掉。

另一个好处是**解耦**，消息的生产者只需要将消息发送给RabbitMQ，这些消息什么时候处理完，不会影响生产者的响应性能。

### 相关概念：

通常我们谈到队列服务, 会有三个概念： 发消息者、队列、收消息者，**RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在发消息者和 队列之间, 加入了交换器 (Exchange)。** 这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列。

![1557897648865](E:\git\知识点整理\figure\RabbitMQ.png)

- 左侧 P 代表 生产者，也就是往 RabbitMQ 发消息的程序。
- 中间即是 RabbitMQ，*其中包括了 交换机 和 队列。*
- 右侧 C 代表 消费者，也就是往 RabbitMQ 拿消息的程序。

#### **比较重要的概念有4个，分别为：虚拟主机，交换机，队列和绑定。**

**虚拟主机：**一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？RabbitMQ中，用户只能在虚拟主机的粒度进行权限控制，因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个RabbitMQ服务器都有一个默认的虚拟主机”/“。

**交换机：**Exchange用于转发消息，但是它不会做存储，如果没有Queue bind到Exchange的话，它会直接丢弃掉Producer发送过来的消息。这里有一个比较重要的概念：路由键。消息到交换机的时候，交换机会转发到对应的队列中，那么究竟是转发到哪个队列，就要根据该路由键进行匹配。

**绑定：**也就是交换机需要和队列相绑定。

#### **交换机（Exchange）**

交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。交换机有四种类型：Direct，topic，Headers and Fanout

**Direct：**direct类型的行为是"先匹配，再投送"。即在绑定时设定一个routing_key，消息的routing_key匹配时，才会被交换器投送到绑定的队列中去。

**Topic：**按规则转发消息（最灵活）

**Headers：**设置header attribute参数类型的交换机

**Fanout：**转发消息到所有绑定队列

#### **Direct Exchange**

Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。

#### **Topic Exchange**

Topic Exchange转发消息主要是根据通配符。在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。

**在这种交换机模式下：**

- 路由键必须是一串字符，用句号（`.`） 隔开，比如说 agreements.us，或者 agreements.eu.stockholm 等。
- 路由模式必须包含一个 星号（`*`），主要用于匹配路由键指定位置的一个单词，比如说，一个路由模式是这样子：agreements..b.*，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin 开头的路由键都是可以的。

topic 和 direct 类似, 只是匹配上支持了"模式", 在"点分"的 routing_key 形式中, 可以使用两个通配符:

- `*`表示一个词.
- `#`表示零个或多个词.

#### **Header Exchange**

headers也是根据规则匹配，相较于direct和topic固定地使用routing_key，headers则是一个自定义匹配规则地类型。在队列与交换器绑定时，会设定一组键值对规则，消息中也包括一组键值对（headers属性），当这些键值对有一对，或全部匹配时，消息被投送到对应队列。

#### **Fanout Exchange**

Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，*会把消息发给绑定给它的全部队列*，如果配置了 routing_key 会被忽略。

#### **Springboot集成RabbitMQ**

<https://www.cnblogs.com/ityouknow/p/6120544.html>

**Springboot集成rabbitMQ消息队列搭建与ACK消息确认：**

<https://blog.csdn.net/linpeng_1/article/details/80505828>

### ACK机制

**什么是消息确认ACK？**

如果在处理消息地过程中，消费者地服务器在处理消息时出现异常，那可能这条正在处理地消息就没有完成消息消费，数据就会丢失。为了确保数据不会丢失，RabbitMQ支持消息确认-ACK

**ACK的消息确认机制**

ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除。

1）如果一个消费者在处理消息出现了网络不稳定，服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中。

2）如果在集群的情况下：RabbitMQ会立即将这个消息推送给这个在线的其它消费者。这种机制保证了在消费者服务端故障的时候，不丢失任何消息和任务。

3）消息永远不会从RabbitMQ中删除：只有当消费者正确发送ACK反馈，RabbitMQ确认收到后，消息才会从RabbitMQ服务器的数据中删除。

4）消息的ACK确认机制默认是打开的。

**ACK机制的开发注意事项**

如果忘记了ACK，那么后果很严重。当Consumer退出时，Message会一直重新分发。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，因此这个"内存泄漏"是致命的。

> 通俗的说，RabbitMQ为了保证消息的发送者在发出消息后要知道接收者是否正确的接收到消息，为了保证消息不丢失，则接收者必须反馈，如果发送者没有接收到反馈，那么默认情况下将一直发送消息。这时如果在接收者这块出现异常，那么就会导致死循环，消息则会不停地发送，内存会暂用越来越多。为了避免内存溢出情况发生，开启重试机制即可。

