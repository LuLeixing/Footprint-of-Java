# 进程与线程

## 1.进程

进程是资源分配的基本单位

进程控制块（Process Control Block,PCB）描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对PCB的操作。

## 2.线程

线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ和浏览器是两个进程，浏览器进程里有很多线程，例如HTTP请求线程，事件响应线程，渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起HTTP请求时，浏览器还可以响应用户的其它事件。

## 区别

### 1.拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

### 2.调度

线程是独立调度的基本单位，在同一个进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

### 3.系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间，I/O设备等，所付出的开销远大于创建或撤销线程时的开销。类似的，在进行进程切换时，涉及当前执行进程CPU环境的保持及新调度进程CPU环境的设置，而线程切换时只需保持和设置少量寄存器内容，开销很小。

### 4.通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。



# 进程状态的切换

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

![](E:\git\知识点整理\figure\操作系统\进程管理进程状态转换.png)

### 应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得CPU时间，转为运行状态；而运行状态的进程，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，**但是该资源不包括CPU时间，缺少CPU时间会从运行态转化为就绪态。**



# 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

## 1.批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

### 1.1 先来先服务first-come first-served（FCFS）

按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

### 1.2 短作业优先 shortest job first（SJF）

按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一致等待短作业执行完毕的状态，因为如果一直有短作业到来，那么长作业永远得不到调度。

### 1.3 最短剩余时间优先 shortest remaining time next(SRTN)

按估计剩余时间最短的顺序进行调度。

## 2.交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

### 2.1时间片轮转

将所有就绪进程按照先来先服务FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保持进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换地太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

### 2.2 优先级调度

为每一个进程分配一个优先级，按照优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

### 2.3 多级反馈队列

一个进程需要执行100个时间片，如果采用时间片轮转调度算法，那么需要交换100次。**多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1，2，4，8....进程在第一个队列没执行完，就会被移到下一个队列。**这种方式下，之前的进程只需要交换7次。每个队列优先权也不同，最上面的优先权最高，因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

## 3.实时系统

实时系统要求一个请求在一个确定的时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

# 进程同步

## 1.临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```java
// entry section
// critical section;
// exit section
```

## 2.同步与互斥

同步：多个进程按一定顺序执行；

互斥：多个进程在同一时刻只有一个进程能进入临界区。

## 3.信号量

参考资料，讲的形象生动：<https://blog.csdn.net/u014495460/article/details/82883282>

一个结构体，包含一个整数value和一个PCB指针queue，其中value表示空闲资源数，queue指向PCB队列。只要有了queue指针，就可以维护这个队列，这个队列的意义就是等待区。

### **P操作**

一个指令序列。P=排=盼=push，表示使用资源、入队。
P操作是对信号量的操作。
指令序列是这样的：

- 令value减少1。
- 如果value<0，休眠（把进程排在队尾，并令进程进入等待状态）。

### **V操作**

一个指令序列。V=victory=耶(●’◡’●)，表示资源释放、出队。
V操作是对信号量的操作。
指令序列是这样的：

- 令value增加1。
- 如果value≤0，唤醒（将队列首的进程取出，并使其进入就绪状态）。

**value为1时表示资源空闲，value为0时表示虽然队列是空的但是资源正在使用，value为负数时其绝对值表示排队的进程数。**

信号量（Semaphore）是一个整型变量，可以对其执行down和up操作，也就是常见的P和V操作。

- down：如果信号量大于0，执行-1操作；如果信号量等于0，进程睡眠，等待信号量大于0；
- up：对信号量执行+1操作，唤醒睡眠的进程让其完成down操作。

## 4.管程

//TODO



# 经典同步问题

1.读者-写者问题

2.哲学家进餐问题



# 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序进行；
- 进程通信：进程间传输信息；

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

## 1.管道

管道是通过调用pipe函数创建的，fd[0]用于读，fd[1]用于写。

```c++
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

- 只支持半双工通信（双向替换传输）；
- 只能在父子进程中使用。

![](E:\git\知识点整理\figure\操作系统\进程间通信管道.png)

## 2.FIFO

也称为命名管道，去除了管道只能在父子进程中使用的限制。

```c++
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。

![1555660591994](C:\Users\LULEIX~1\AppData\Local\Temp\1555660591994.png)

## 3.消息队列

相比于FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难；
- 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收。

## 4.信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

## 5.共享存储

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外XSI共享内存不是使用文件，而是使用内存的匿名段。

## 6.套接字

与其它通信机制不同的是，它可用于不同机器之间的进程通信。